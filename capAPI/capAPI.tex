
%-------------------------------------------------------------
%				RENDERED PRICES API
%-------------------------------------------------------------

\mcchap{API rendered prices}{cap:api}

Una volta implementati i vari Widget delle componenti in homepage le specifiche di poter
modificare il contenuto delle componenti da interfaccia grafica e senza editare
il codice HTML, di poter creare copie delle componenti già create, e di poter spostare
semplicemente con drag and drop le varie componenti risultavano soddisfatte.

L'uncio problema rimanente dunque era quello di avere un feedback visivo immediato mentre si edita
la pagina.

Il feedback visivo era già presente per quelle componenti senza prodotti il cui HTML risiedeva in Wordpress,
per le componenti che fanno uso di prodotti invece l'utente che usava Wordpress non vedeva niente renderizzato.

Questo perchè una volta compilato il Widget, Wordpress renderizza il tag \emph{dynamic} e non i prodotti,
questi compaiono solo una volta che la pagina Wordpress viene processata da Kiruby, che trovando il tag \emph{dynamic}
lo sostituisce con l'HTML.

Per risolvere questa problema è stato deciso di implementare nel server Kiruby delle API chiamate
\emph{rendered\_API} che fatte delle richieste con gli ID dei prodotti e altri parametri come titolo e descrizione
ritorna l'HTML con tutte le schede prodotto ed eventuali intestazioni.

Queste API poi vengono chiamate da Wordpress che riceve subito l'HTML e lo renderizza immediatamente,
le stesse API vengono anche chiamate da \emph{cms\_dealer} per renderizzare i tag \emph{dynamic}.

Per spiegare il meccanismo delle rendered API prendiamo in considerazione il meccanismo utilizzato per il widget
\emph{Origini - Slider Prodotti}.

Altri Widgets come \emph{Origini - Slider Accessori}, \emph{Kirivo - Slider Prodotti} e \emph{Kirivo - Griglia Prodotti}
utilizzano un meccanismo praticamento identico ma utilizzano differenti template HTML.

\section{Creazione chiamata in Wordpress}
Inanzitutto per tutti quei Widget che fanno chiamate alle API è stata creata una superclasse PHP comune chiamata
\emph{AbstractProductWid}.
Qui nel metodo \emph{widget}, che stampa l'HTML del Widget, viene stampato il contentuo che si riceve facendo la chiamata alle
API. Questa chiamata viene composta con il metodo \emph{composeUrl}.

\begin{lstlisting}[style=customphp, language=Php,caption={I metodi widget e \emph{callApiAndRender} di \emph{AbstractProductWid}}] 
function widget($args, $instance){
	$this->callApiAndRender($this->composeUrl($instance));
}

function callApiAndRender($url) {
	$api_response = wp_remote_get($url);
	$api_data = json_decode( wp_remote_retrieve_body
		( $api_response ), true );
	echo str_replace('\n','',$api_data['rendered_html']);
}
\end{lstlisting}

Il metodo composeUrl della classe \emph{AbstractProductWid} inizia a comporre la chiamata con quei campi
comuni a tutti i Widget che fanno chiamate alle API ovvero: gli ID dei prodotti, e il titolo della sezione.

\begin{lstlisting}[style=customphp, language=Php,caption={Il metodo \emph{composeUrl} di \emph{AbstractProductWid}}] 
function composeUrl($instance) {
    $api_request = getHost();
    $api_request .= '/iguana/api/cms/' . $this->iguanaApiRoute() . 
    	'?product_ids=' . $instance['ids'];

    if(!is_null($instance['title'])) {
        $api_request .= "&title=".urlencode($instance['title']);
    }

    return $api_request;
}

\end{lstlisting}

Le classi che estendono \emph{AbstractProductWid} poi devono definire il metodo \emph{iguanaApiRoute} che specifica
a quale rotta il Widget deve fare la chiamata ed eventualmente aggiungere campi alla chiamata sovrascrivendo \emph{callApiAndRender}.

Ad esempio il codice del Widget \emph{Origini - Slider Prodotti} che deve fare la chiamata alla rotta \emph{/iguana/api/cms/rendered\_box\_prices} e aggiungere  anche i campi link allo scopri altro e sottotitolo sarà:

\begin{lstlisting}[style=customphp, language=Php,caption={I metodi widget \emph{composeUrl} e \emph{iguanaApiRoute} di \emph{ProductsWidget}}] 
function iguanaApiRoute() {
    return 'rendered_box_prices';
}

function composeUrl($instance) {
    $api_request = parent::composeUrl($instance);
    if(!is_null($instance['subtitle'])) {
        $api_request .= "&subtitle=".urlencode($instance['subtitle']);
    }
    if(!is_null($instance['scopri-link'])) {
        $api_request .= "&link=". urlencode($instance['scopri-link']);
    }

    return $api_request;
}
\end{lstlisting}

\section{Creazione risposta in Kiruby}